---
title: "ML- algs testing"
author: "J. Sebastian Paez"
date: "`r Sys.Date()`"
output: 
  html_document: 
  rmdformats::material:
    highlight: kate
    keep_md: yes
params:
    SEURAT_RDS: 'seurat_mix5050.RDS'
    MARKERS_RDS: 'markers_mix5050.RDS'
    GLOBAL_REPEATS: 1
    NUM_CROSS_VAL: 2
    DATA_FRACTION: 0.01
    FILTER_MEMBRANE: TRUE
    NUMTHREADS: 2
    DATASET_ID: 'somerandomname'
    CLUSTER: 'X1'

---


```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print = "75")
opts_chunk$set(echo = TRUE,
	             cache = FALSE,
               prompt = FALSE,
               tidy = TRUE,
               comment = NA,
               message = TRUE,
               warning = TRUE)
opts_knit$set(width = 75)
```

# Setup

```{r}
warning(str(params))
```


```{r}
library(doSNOW)
cl <- makeCluster(params$NUMTHREADS, type = "SOCK")
registerDoSNOW(cl)

```

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
library(Seurat)
library(ggplot2)
library(plyr)
library(dplyr)
library(ranger)
library(party)
library(caret)
library(org.Hs.eg.db)
```

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
print(params)
dataset <- readRDS(params$SEURAT_RDS)
markers <- readRDS(params$MARKERS_RDS)

set.seed(42)
```

# Helper Functions

```{r}
#' Gets a data frame from a seurat object
#' 
#' Provided a seurat object, returs a data frame of the count values, being 
#' the columns each 'gene' and the rows each UMI/cell.
#'
#' It returns only the genes annotated as variable and the identity column.
#'
#' @param seurat A seurat object
#'
#' @return
#' @export
#'
#' @examples
#' > as.data.frame.Seurat(dataset.minus_small)[1:3,1:3]
#'                    LTB EAF2 CD19
#' ATGCCAGAACGACT 6.062788    0    0
#' CATGGCCTGTGCAT 6.714813    0    0
#' GAACCTGATGAACC 7.143118    0    0
#' @importFrom Seurat FetchData GetIdent
as.data.frame.Seurat <- function(seurat) {
    tmp <- Seurat::FetchData(seurat, vars.all = seurat@var.genes)
    tmp <-  as.data.frame(tmp, stringsAsFactors = FALSE)

    tmp$ident <- Seurat::GetIdent(
      seurat, uniq = FALSE, cells.use = rownames(tmp))
    return(tmp)
}


dataset.df <- as.data.frame.Seurat(dataset)

# Some minor renaming is required for most methods, since some genes have - in 
# their names, and we require R-valid names.

original_names <- colnames(dataset.df)
newnames <- make.names(original_names)
colnames(dataset.df) <- newnames
dim(dataset.df)
```


```{r}

# The markers df object is supposed to be comming form Seurat's FindAllMarkers
fit_models <- function(forest_topgenes, 
                       wilcox_topgenes,
                       wilcox_topgenes_local,
                       train_df,  numrepeats = 1,
                       ncv = 2, verbose = FALSE) {
  
  weights_vars <- ceiling(1/(table(train_df$ident) / max(table(train_df$ident))))
  
  ranger_train_template <- function(dataset, weights_vars = NULL) {
    trainCtrl_ranger <- trainControl(
      method = 'repeatedcv', 
      repeats = numrepeats,
      number = ncv, verboseIter = verbose, 
      allowParallel = FALSE, classProbs = TRUE)
        
    ranger_tune <- expand.grid(
      .mtry = ceiling(c(sqrt(ncol(train_df)), 
                        ncol(train_df)/10, 
                        ncol(train_df)/5)),
      .splitrule = c('gini', 'extratrees'),
      .min.node.size = c(5,10,50,100))
    
    time_taken <- system.time({
      ret <- try({train(
        ident ~ ., 
        data = dataset, 
        method = 'ranger',
        trControl = trainCtrl_ranger, 
        tuneGrid = ranger_tune,
        class.weights = weights_vars)})
    })
    
    return(list(time = time_taken, model = ret))
  }
  
  train_glmnet_template <-  function(train_df) {
     trainCtrl <- trainControl(
      method = 'repeatedcv', 
      repeats = numrepeats,
      number = ncv, verboseIter = verbose, 
      allowParallel = TRUE, classProbs = TRUE)
    
    time_taken <- system.time({ 
      fit <- try({train(
        ident ~ ., 
        data = train_df, 
        method = 'glmnet',
        trControl = trainCtrl)})
    })
    return(list(time = time_taken, model = fit))
  }
  
  ctree_fit_template <- function(dataset) {
    trainCtrl_ranger <- trainControl(
      method = 'repeatedcv', 
      repeats = numrepeats,
      number = ncv, verboseIter = verbose, 
      allowParallel = FALSE, classProbs = TRUE)
    
    tree_tune <- expand.grid(
    .mincriterion = c(0.5, 0.95, 0.99), 
    .maxdepth = as.integer(seq(3, 10, 4)))
    
    time_taken <- system.time({ 
      fit <- try({train(
        ident ~ ., 
        data = dataset, 
        method = 'ctree2',
        trControl = trainCtrl_ranger,
        tuneGrid = tree_tune)}) 
    })
    return(list(time = time_taken, model = fit))
    
  }

  ranger_fit_weighted <- ranger_train_template(
    train_df, 
    weights_vars = weights_vars) 

  message("Done with one trainning - RF")
  
  ranger_fit_non_weighted <- ranger_train_template(
    train_df, 
    weights_vars = NULL) 

  message("Done with one trainning - RF")
  
  glmnet_fit_global <- train_glmnet_template(train_df)

  message("Done with one trainning - GLMNET")

  ############################################################################
  ################### Subset Based on ranger Importances - Local
  
  my_formula <- as.formula("ident ~ .")
  
  importance_ranger <- ranger::ranger(
    my_formula, data =  train_df,
    importance = "permutation",
    mtry = ranger_fit_weighted$bestTune$mtry,
    splitrule = ranger_fit_weighted$bestTune$splitrule,
    min.node.size = ranger_fit_weighted$bestTune$min.node.size,
    num.trees = 1000)
  
  tmp_importances  <- ranger::importance_pvalues(
    importance_ranger, method = "altmann", formula = my_formula, 
    data = dataset.df)
  
  df_importances <- as.data.frame(
    tmp_importances[tmp_importances[, "pvalue"] < 0.05, ])
  df_importances$Gene <- rownames(df_importances)
  
  df_importances <- top_n(df_importances, 30, importance)
  topgenes_forest_local <- forcats::fct_reorder(
    df_importances$Gene,
    df_importances$importance)
  
  train_df_top_local_forest <- train_df[, c(as.character(topgenes_forest_local), "ident")]
  
  ctree_fit_local_forest <- ctree_fit_template(train_df_top_local_forest)
  
  message("Done with one trainning - CTREE")

  glmnet_fit_local_forest <- train_glmnet_template(train_df_top_local_forest)

  message("Done with one trainning - GLMNET")

  ################### Seurat-derived

  train_df_top_local_wilcox <- train_df[, colnames(train_df) %in% c(wilcox_topgenes_local, "ident")]

  ctree_fit_local_wilcox <- ctree_fit_template(train_df_top_local_wilcox)
  
  message("Done with one trainning - CTREE")

  glmnet_fit_local_wilcox <- train_glmnet_template(train_df_top_local_wilcox)

  message("Done With all trainings in a round - GLMNET")
  
  
  
  ############################################################################
  ################### Subset Based on global passed genes -  Global
  
  ################### Forest

  train_df_top_global_forest <- train_df[, c(forest_topgenes, "ident")]

  ctree_fit_global_forest <- ctree_fit_template(train_df_top_global_forest)
  
  message("Done with one trainning - CTREE")

  glmnet_fit_global_forest <- train_glmnet_template(train_df_top_global_forest)

  message("Done With all trainings in a round - GLMNET")
  
  ################### Seurat-derived

  train_df_top_global_wilcox <- train_df[, colnames(train_df) %in% c(wilcox_topgenes, "ident")]

  ctree_fit_global_wilcox <- ctree_fit_template(train_df_top_global_wilcox)
  
  message("Done with one trainning - CTREE")

  glmnet_fit_global_wilcox <- train_glmnet_template(train_df_top_global_wilcox)

  message("Done With all trainings in a round - GLMNET")
  
  # TODO consider if it owuld be better to save the models as they are and
  # then use batch jobs to do all the processing ....

  
  models <- list(forest_unweighted = ranger_fit_non_weighted,
      forest_weighted =  ranger_fit_weighted,
      glmnet_fit_global = glmnet_fit_global,
      glmnet_fit_local_wilcox = glmnet_fit_local_wilcox,
      glmnet_fit_local_forest = glmnet_fit_local_forest,
      # ctree_fit_global = ctree_fit_global,
      ctree_fit_local_wilcox = ctree_fit_local_wilcox,
      ctree_fit_local_forest = ctree_fit_local_forest)
  
  ret <- tibble(
    models = purrr::map(models, function(x) try(x$model)),
    runtime = purrr::map(models, function(x) try(x$time)),
    final_model = purrr::map(models, function(x) try(x$finalModel)),
    results = purrr::map(models, function(x) try(x$results)), 
    best_acc = purrr::map(models, function(x) try(max(x$results$Accuracy))),
    best_kappa = purrr::map(models, function(x) try(max(x$results$Kappa))))

  return(ret)
  
}


make_df_for_cluster <- function(df, cluster_name) {
  df$ident <- make.names(df$ident) == make.names(cluster_name)
  df$ident <- factor(make.names(df$ident))
  
  return(df)
}

template_fit_model_for_cluster <- function(dataset, clustername, 
                                           topgenes, savename,
                                           markers_df,
                                           numrepeats,
                                           ncv, verbose) {

  local_markers_df <- markers_df[make.names(markers_df$cluster) %in% 
                                 make.names(clustername),]

  allmodels <- dataset %>% 
    make_df_for_cluster(clustername) %>%
    fit_models(
      forest_topgenes = topgenes,
      wilcox_topgenes = unique(markers_df$gene),
      wilcox_topgenes_local = unique(local_markers_df$gene),
      train_df = .,
      numrepeats = numrepeats,
      ncv = ncv, verbose = verbose)
  
  saveRDS(allmodels, savename)
  saveRDS(dplyr::select(allmodels, -models), paste0("LEAN_", savename))

  return(allmodels)
}

```

# Calculating External Parameters

```{r}
surface_annotated <- AnnotationDbi::select(
    org.Hs.eg.db,
    keys = dataset@var.genes,
    columns = "GO",
    keytype = "ALIAS") %>% 
    filter(GO %in% c("GO:0009986", "GO:0005886", "GO:0044459"))

surface_annotated <- unique(surface_annotated$ALIAS) 

if (params$FILTER_MEMBRANE) {
  dataset.df <- dataset.df[, colnames(dataset.df) %in% c(surface_annotated, 'ident')]
}

dim(dataset.df)
```

```{r}
train_df <- dataset.df
splitvector <- sample(
  c(T,F), nrow(train_df),
  replace = TRUE,
  prob = c(params$DATA_FRACTION, (1 - params$DATA_FRACTION)))

test_df <- train_df[!splitvector,]
train_df <- train_df[splitvector,]
```


```{r}
# This add weihts to the clusters in proportion to the inverse of their abundance
# TODO find a better way to calculate the weights ...
weights_vars <- ceiling(1/(table(train_df$ident) / max(table(train_df$ident))))

my_formula <- as.formula("ident ~ .")

forest <- ranger::ranger(
  ident ~ ., data =  train_df,
  importance = "impurity_corrected",
  class.weights = weights_vars,
  mtry = ceiling(ncol(train_df)/10),
  num.trees = 2000)

forest

tmp_importances  <- ranger::importance_pvalues(
  forest, method = "altmann", formula = my_formula, 
  data = train_df)


df_importances <- as.data.frame(
  tmp_importances[tmp_importances[, "pvalue"] < 0.05, ])

df_importances$Gene <- rownames(df_importances)

head(df_importances[order(df_importances[, "importance"]), ] )
dim(df_importances)

```

Note that due to the nature of the random forest, it cannot be plotted ...
but importances can

.... since factors are weird in R we need to reorder the levels for the plot to
make sense ...

```{r}
plot_df <- top_n(df_importances, 35, importance)

genes <- forcats::fct_reorder(
  plot_df$Gene,
  plot_df$importance)

ggplot2::qplot(x = plot_df$importance, y = genes) + 
  theme_bw()
```

# Actually Fitting the models

```{r message = FALSE}
message(paste("Cluster", params$CLUSTER))
template_fit_model_for_cluster(
  dataset = train_df, 
  clustername = params$CLUSTER, 
  topgenes = plot_df$Gene,
  markers_df = markers,
  savename = paste0(
    params$DATASET_ID,
    "_cluster",
    params$CLUSTER,".RDS"),
  numrepeats = params$GLOBAL_REPEATS,
  ncv = params$NUM_CROSS_VAL, 
  verbose = FALSE)
```

```{r}
stopCluster(cl)
```

