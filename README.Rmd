---
title: "sctree: a package to connect single cell rna-seq to biology using trees"
output: 
  github_document:
    toc: true
    toc_depth: 2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

[![Travis build status](https://travis-ci.org/jspaezp/sctree.svg?branch=master)](https://travis-ci.org/jspaezp/sctree)
[![Coverage status](https://codecov.io/gh/jspaezp/sctree/branch/master/graph/badge.svg)](https://codecov.io/github/jspaezp/sctree?branch=master)

# sctree

The goal of sctree is to create a tool to accelerate the transition from
single cell rna-sequencing to calidation and new sub-population discovery.

Features suggesting pseudo-gating strategies to purify found populations via
flow-cytometry, antibody querying and cross validations between datasets.

Number of lines in roxygen comments:
`r system2("bash", "-c \"grep -RP '^#' ./R | wc -l\"", stdout = TRUE)`

Number of lines in R code:
`r system2("bash", "-c \"grep -RP '^[^#]' ./R | grep -vP '^$' | wc -l \"", stdout = TRUE)`

# Installation

```
git clone https://github.rcac.purdue.edu/jpaezpae/sctree sctree
cd sctree

R -e "devtools::install('.')"
```

# Usage

I am assuming you have already done your clustering and dimensional reduction
using seurat and we have our seurat object.

For this examples we will use a dummy dataset that come bundled with the package

`small_5050_mix`, this dataset comes originally from the 1:1 mixture of Jurkat 
and 293T cells provided by 10x.

Original data can be found here:

1. [1:1 mixture](https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/jurkat:293t_50:50)
2. [99:1 mixture](https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/jurkat_293t_99_1)


```{r}
require(sctree)
require(Seurat)

set.seed(6)

data(small_5050_mix)
small_5050_mix

DimPlot(small_5050_mix, reduction = "tsne")
```

```{r child="vignettes/rmdchunks/finding_markers.Rmd"}
```

## Visualizing the expected outcome of a flow cytometry experiment

Lets say we choose the top 5 markers from the former list and we did a flow
experiment ... HYPOTHETICALLY the marker distribution would resemble the rna
expression profile for which we have the function `plot_flowstyle`

```{r}
top_markers <- head(rang_importances[[3]]$gene)
top_markers
g <- plot_flowstyle(small_5050_mix, markernames = top_markers)
g
```

Based on this, we can see that the red cluster in this plot is predominantly
CD3+ ADA+ and ARHGDIB+, as well as ASNS-

We can also focus in one of the pannels (and check the color conventions)

```{r}
g[1,2]
```


## Suggesting a gating strategy for the markers

A general strategy to get separate all clusters

```{r}

top_markers <- head(rang_importances[[3]]$gene)

tree_fit <- fit_ctree(small_5050_mix,
                      genes_use = top_markers, 
                      cluster = "ALL")
```

Visualizing the tree as ... a tree ... we can see how our model is a simple
series of yes/no questions.

If we wanted to classifiy a random cell: in the first `node`, we check if the 
expression of that gene is higher or lower than a given value, if it is lower,
we proceed to the left, if not we go right. We keep doing that until we have no
more `branches`. This final node will have a predicted cluster, in this plot we
can also see how pure can we expect this group to be and how many of the cells
in our training set clasify as part of it.

```{r fig.height=5, fig.width=12}
plot(tree_fit)
```

When inspecting the tree_fit, we can see a more detailed text representation
of this tree.

```{r}
print(tree_fit)
```

Sometimes one might think that the proposed strategy is too complicated or not
implementable in the experimental settings, in order to add constrians to the fit
one can give additional arguments that will be passed to
`partykit::ctree_control`, such as `maxdepth = 2` (maximum 2 questions per cell)

```{r fig.height=5, fig.width=12}
tree_fit <- fit_ctree(
  small_5050_mix, genes_use = top_markers, 
  cluster = "ALL", maxdepth = 2)
print(tree_fit)
plot(tree_fit)
```

Since not all variables are ultimately used in our classifier, one can acces the
ones that were by using `varimp(tree_fit)`

```{r}
partykit::varimp(tree_fit)
plot_flowstyle(small_5050_mix, names(partykit::varimp(tree_fit)))
```


One can also request the package to suggest a specific strategy only for a given
cluster. This function is not expected to give drastically different results in 
datasets with few clusters, but it can definitely come usefull when many clusters
are present and one is interested in a specific one. 

```{r}
tree_fit <- fit_ctree(small_5050_mix, genes_use = top_markers, cluster = "0")
print(tree_fit)
```


## Finding equivalent clusters in two datasets

```{r}
data(small_9901_mix)
small_9901_mix
```


```{r}
validation_results <- cross_validate(
    small_5050_mix, small_9901_mix, 
    cluster = "ALL",
    warn.imp.method = FALSE)

validation_results[[1]]
```

```{r}
validation_results$confusion_matrix

```

```{r}
freq_matrix <- as.frequency.matrix(validation_results$confusion_matrix)
freq_matrix
```

This would mean that cells in cluster 0 in the `small_9901_mix` dataset are 
classified `r freq_matrix["0","0"]` % of the time as bleonging to cluster 0 of 
the `small_5050_mix`

These frequencies can be visualized by plotting them in a heatmap

```{r fig.height=3, fig.width=6}

autoplot(freq_matrix,
         min_color = 50,
         show_number = TRUE)
```

Here we can see that in the *9901* dataset (predicted), both clusters 0 and 1
are classified mostrly as cluster 0 in the *5050* dataset, while the cluster 2
is mainly classified as 1.

(remember that the numbers are arbitrary and only mean something within 
each dataset)

```{r}
print(validation_results[[3]])
```


```{r}
gating_genes <- validation_results$gating_genes
gating_genes
```

```{r}
g1 <- plot_flowstyle(small_5050_mix, markernames = gating_genes)
g2 <- plot_flowstyle(small_9901_mix, markernames = gating_genes)
 
g1
g2
```

```{r}
g2[1,2]
```


## Finding antibodies for the experiment

Since we acknowledge most experimental workflows need antibodies. We have 
implemented several functions to look for antibodies in vendor websites, as well
as some helper functions to find the other posible aliases a gene might have.

Here is a simple example for a gene widely know to have an antibody available

```{r}
head(query_biocompare_antibodies("CD11b"))
```


```{r}
sessionInfo()
```


# Steps down the road

3. Address some of the TODO's in this repository
4. Reduce dependecies by replacing functions to base equivalents.
5. Add links to the documentation to make nicer to explore the package from inside R
6. Implement plot that actually illustrates the progressive gating in the decision tree
8. Implement a way to find markers for clusters exclusively upregulated
9. Refctor the code to make the coding nomenclature same as seurat


